;;             Fortuna.ton
;;  Ticket smart contract by TONLab.pro

;;
;;  Storage
;;
;;  uint64 index
;;  MsgAddressInt collection_address
;;  MsgAddressInt owner_address
;;  uint32 last_draw_time
;;  ref individual_content
;;

#include "op-codes.fc";
#include "params.fc";


slice to_string(int n) {
  builder b = begin_cell();
  tuple chars = null();
  do {
    int r = n~divmod(10);
    chars = cons(r + "0"u, chars);
  } until (n == 0);
  do {
    int char = chars~list_next();
    b~store_uint(char, 8);
  } until (null?(chars));
  return b.end_cell().begin_parse();
}

(int, int, slice, slice, int) load_data() {
    slice ds = get_data().begin_parse();
    var (index, collection_address) = (ds~load_uint(64), ds~load_msg_addr());
    if (ds.slice_bits() > 0) {
      return (-1, index, collection_address, ds~load_msg_addr(), ds~load_uint(32));
    } else {
      return (0, index, collection_address, null(), 0);
    }
}

() store_data(int index, slice collection_address, slice owner_address, int last_draw_time) impure {
    set_data(
        begin_cell()
            .store_uint(index, 64)
            .store_slice(collection_address)
            .store_slice(owner_address)
            .store_uint(last_draw_time, 32)
            .end_cell()
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; always ignore bounced messages
        return ();
    }

    (int init?, int index, slice collection_address, slice owner_address, int last_draw_time) = load_data();

    slice sender_address = cs~load_msg_addr();

    int is_collection? = equal_slices(collection_address, sender_address);

    if (~ init?) {
        throw_unless(405, is_collection?);
        store_data(index, collection_address, in_msg_body~load_msg_addr(), in_msg_body~load_uint(32));
        return ();
    }

    ;; ticket sometimes stays in the wallet because some apps have bad indexing systems (Tonkeeeepeer),
    ;; so owner can immitate the transfer to remove it from the app like an nft
    if ( equal_slices(sender_address, owner_address) & (~ is_collection?) & (last_draw_time < now()) ) {
        var msg = begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(owner_address)
                    .store_coins(0)
                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                    .store_uint(op::excesses(), 32)
                    .store_uint(now(), 64)
                  .end_cell();

        send_raw_message(msg, 64); ;; carry all the remaining value

        store_data(index, collection_address, collection_address, last_draw_time);
        return ();
    }

    throw_unless(405, is_collection?);

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    if (op == op::transfer()) {
        slice new_owner_address = in_msg_body~load_msg_addr();
        int draw_time = in_msg_body~load_uint(32);
        force_chain(new_owner_address);
        store_data(index, collection_address, new_owner_address, draw_time);
        return ();
    }

    if (op == op::owner_request()) {
        cell prize = in_msg_body~load_ref();
        var msg = begin_cell()
                   .store_uint(0x18, 6)
                   .store_slice(sender_address)
                   .store_coins(0)
                   .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                   .store_uint(op::owner_response(), 32)
                   .store_uint(query_id, 64)
                   .store_uint(index, 64)
                   .store_slice(owner_address)
                   .store_ref(prize)
                  .end_cell();
                    
        send_raw_message(msg, 64);
        return ();
    }
    throw(0xffff);
}

;;
;;  GET Methods
;;

(int, int, slice, slice, cell) get_nft_data() method_id {
    (int init?, int index, slice collection_address, slice owner_address, int last_draw_time) = load_data();

    if (last_draw_time < now()) {
        owner_address = collection_address;
    }

    slice str_index = to_string(index);
    cell content = begin_cell()
                     .store_slice(str_index)
                     .store_slice(".json")
                   .end_cell();

    return (init?, index, collection_address, owner_address, content);
}

int get_draw_time() method_id {
    var (_, _, _, _, last_draw_time) = load_data();
    return last_draw_time;
}
